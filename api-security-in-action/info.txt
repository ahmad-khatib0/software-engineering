 ╒═══════════════════════════════════════════════════════════════════════════════════════════════╕
     An origin is the combination of protocol, host name, and port, so a change to any of these 
      will cause the browser to treat it as a separate origin.)                                     
 └───────────────────────────────────────────────────────────────────────────────────────────────┘

 ╒═══════════════════════════════════════════════════════════════════════════--═╕
    DEFINITION                                                                 
     A marker interface is an interface that defines no new methods. It is used 
     purely to indicate that the implementation has certain desirable properties.
 └───────────────────────────────────────────────────────────────────────────--─┘

## There are several popular approaches to exposing remote APIs:
  The gRPC framework from Google (https://grpc.io) is an example of a modern RPC approach. The older 
   SOAP (Simple Object Access Protocol) framework, which uses XML for messages, is still widely deployed.
  A variant of the RPC style known as Remote Method Invocation (RMI) uses object-oriented techniques to 
   allow clients to call methods on remote objects as if they were local. RMI approaches used to be very 
   popular, with technologies such as CORBA and Enterprise Java Beans (EJBs) often used for building large
   enterprise systems The complexity of these frameworks has led to a decline in their use
j The REST (REpresentational State Transfer) style was developed by Roy Fielding to describe the principles 
   that led to the success of HTTP and the web and was later adapted as a set of principles for API design. 
   In contrast to RPC, RESTful APIs emphasize standard message formats and a small number of generic operations
   to reduce the coupling between a client and a specific API. Use of hyperlinks to
   navigate the API reduce the risk of clients breaking as the API evolves over time.


== if your APIs are serving requests on port 80 (for HTTP) and 443 (for HTTPS), then the firewall would be 
   configured to block any requests for any other ports. A load balancer will then route traffic to appropriate 
   services and ensure that one server is not overloaded with lots of requests while others sit idle. Finally, 
   a reverse proxy (or gateway) is typically placed in front of the application servers to perform computationally 
   expensive operations like handling TLS encryption (known as SSL termination) and validating credentials on requests.

== SSL termination1 (or SSL offloading) occurs when a TLS connection from a client is handled by a load 
   balancer or reverse proxy in front of the destination API server. A separate connection from the proxy to 
   the backend server is then made, which may either be unencrypted (plain HTTP) or encrypted as a separate 
   TLS connection (known as SSL re-encryption).

  An API gateway is a specialized reverse proxy that can make different APIs appear as if they are a single 
   API. They are often used within a microservices architecture to simplify the API presented to clients. 
   API gateways can often also take care of some of the aspects of API security discussed in this book, such 
   as authentication or rate-limiting.
  A web application firewall (WAF) inspects traffic at a higher level than a traditional firewall and can 
   detect and block many common attacks against HTTP web services.
  An intrusion detection system (IDS) or intrusion prevention system (IPS) monitors traffic within your internal 
   networks. When it detects suspicious patterns of activity it can either raise an alert or actively attempt 
   to block the suspicious traffic.


The most famous of these (standard security goals) are the so-called “CIA Triad”:
  Confidentiality—Ensuring information can only be read by its intended audience
  Integrity —Preventing unauthorized creation, modification, or destruction of information
  Availability —Ensuring that the legitimate users of an API can access it when
   they need to and are not prevented from doing so.


STRIDE, which stands for:
  Spoofing—Pretending to be somebody else
  Tampering—Altering data, messages, or settings you’re not supposed to alter
  Repudiation—Denying that you did something that you really did do
  Information disclosure—Revealing information that should be kept private
  Denial of service—Preventing others from accessing information and services
  Elevation of privilege—Gaining access to functionality you’re not supposed to have access to


There are many cases in which you are evaluating code that may not be as obvious as calling an
  explicit eval function, such as:
  Building an SQL command or query to send to a database
  Running an operating system command
  Performing a lookup in an LDAP directory
  Sending an HTTP request to another API
  Generating an HTML page to send to a web browser


Header and log injection
  There are examples of injection vulnerabilities that do not involve code being executed at all. For example,
  HTTP headers are lines of text separated by carriage return and new line characters ("\r\n" in Java). If 
  you include unvalidated user input in a HTTP header then an attacker may be able to add a "\r\n" character 
  sequence and then inject their own HTTP headers into the response. The same can happen when you include 
  user-controlled data in debug or audit log messages (see chapter 3), allowing an attacker to inject fake 
  log messages into the log file to confuse somebody later attempting to investigate an attack.

== A buffer overflow might seem harmless enough; it just corrupts some memory, so maybe we get an invalid 
   value in a variable, right? However, the memory that is overwritten may not always be simple data and, 
   in some cases, that memory may be inter- preted as code, resulting in a remote code execution vulnerability. 
   Such vulnerabilities are extremely serious, as the attacker can usually then run code in your process 
   with the full permissions of your legitimate code.

Insecure deserialization
  Although Java is a memory-safe language and so less prone to buffer overflow attacks, that does not mean 
  it is immune from RCE attacks. Some serialization libraries that convert arbitrary Java objects to and 
  from string or binary formats have turned out to be vulnerable to RCE attacks, known as an insecure 
  deserialization vulnerability in the OWASP Top 10. This affects Java’s built-in Serializable framework, 
  but also parsers for supposedly safe formats like JSON have been vulnerable, such as the popular Jackson 
  Databind. a The problem occurs because Java will execute code within the default constructor of any object 
  being deserialized by these frameworks.  Some classes included with popular Java libraries perform dangerous operations in
  their constructors, including reading and writing files and performing other actions. Some classes can even 
  be used to load and execute attacker-supplied bytecode directly. Attackers can exploit this behavior by 
  sending a carefully crafted message that causes the vulnerable class to be loaded and executed.
  The solution to these problems is to allowlist a known set of safe classes and refuse to deserialize any 
  other class. Avoid frameworks that do not allow you to control which classes are deserialized. Consult the 
  OWASP Deserialization Cheat Sheet for advice on avoid insecure deserialization vulnerabilities in several 
  programming languages: https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html.

== Powerful, regular expressions can themselves be a source of attack. Some regular expression 
   implementations can be made to consume large amounts of CPU time when processing certain inputs,
   leading to an attack known as a regular expression denial of service (ReDoS) attack
  
ReDoS Attacks
  A regular expression denial of service (or ReDoS) attack occurs when a regular expression can be forced 
  to take a very long time to match a carefully chosen input string. This can happen if the regular 
  expression implementation can be forced to back-track many times to consider different possible ways 
  the expression might match. As an example, the regular expression ^(a|aa)+$ can match a long string of 
  a characters using a repetition of either of the two branches. Given the input string “aaaaaaaaaaaaab” 
  it might first try matching a long sequence of single a characters, then when that fails (when it sees the 
  b at the end) it will try matching a sequence of single a characters followed by a double-a (aa) sequence,
  then two double-a sequences, then three, and so on. After it has tried all those it might try interleaving
  single-a and double-a sequences, and so on. There are a lot of ways to match this input, and so the pattern 
  matcher may take a very long time before it gives up. Some regular expression implementations are smart 
  enough to avoid these problems, but many popular programming languages (including Java) are not.a Design 
  your regular expressions so that there is always only a single way to match any input. In any repeated part 
  of the pattern, each input string should only match one of the alternatives. If you’re not sure, 
  prefer using simpler string operations instead.
  

Cross-Site Scripting
  Cross-site scripting, or XSS, is a common vulnerability affecting web applications, in
  which an attacker can cause a script to execute in the context of another site. In a
  persistent XSS, the script is stored in data on the server and then executed whenever
  a user accesses that data through the web application. A reflected XSS occurs when
  a maliciously crafted input to a request causes the script to be included (reflected)
  in the response to that request. Reflected XSS is slightly harder to exploit because a
  victim has to be tricked into visiting a website under the attacker’s control to trigger
  the attack. A third type of XSS, known as DOM-based XSS, attacks JavaScript code
  that dynamically creates HTML in the browser.
  These can be devastating to the security of a web application, allowing an attacker
  to potentially steal session cookies and other credentials, and to read and alter data
  in that session. To appreciate why XSS is such a risk, you need to understand that
  the security model of web browsers is based on the same-origin policy (SOP). Scripts
  executing within the same origin (or same site) as a web page are, by default, able
  to read cookies set by that website, examine HTML elements created by that site,
  make network requests to that site, and so on, although scripts from other origins
  are blocked from doing those things. A successful XSS allows an attacker to execute
  their script as if it came from the target origin, so the malicious script gets to do all
  the same things that the genuine scripts from that origin can do. If I can successfully
  exploit an XSS vulnerability on facebook.com, for example, my script could potentially
  read and alter your Facebook posts or steal your private messages.
  Although XSS is primarily a vulnerability in web applications, in the age of single-page
  apps (SPAs) it’s common for web browser clients to talk directly to an API. For this
  reason, it’s essential that an API take basic precautions to avoid producing output
  that might be interpreted as a script when processed by a web browser.

NOTE
  The XSS protections in browsers have been found to cause security vulnerabilities of their own in some 
  cases. The OWASP project now recom mends always disabling the filter with 
  the X-XSS-Protection: 0 header as shown previously.


In a DNS amplification attack, the attacker sends the same DNS query to many DNS servers, spoofing their 
  IP address to look like the request came from the victim. By carefully choosing the DNS query, the 
  server can be tricked into replying with much more data than was in the original query, flooding 
  the victim with traffic

Adding a HSTS header for localhost is not a good idea as it will prevent you from running development servers 
  over plain HTTP until the max-age attribute expires. If you want to try it out, set a short max-age value.

In a production environment you typically will want to send audit logs to a centralized log collection and 
  analysis tool, known as a SIEM (Security Information and Event Management) system, so they can be 
  correlated with logs from other systems and analyzed for potential threats and unusual behavior.

DEFINITION 
  A privilege escalation (or elevation of privilege) occurs when a user with limited permissions can exploit 
  a bug in the system to grant themselves or somebody else more permissions than they have been granted.

Session fixation attacks
  After the user authenticates, the CookieTokenStore then asks for a new session by calling 
  request.session(true). If the request did not have an existing session cookie, then this will create a 
  new session. But if the request already contains an existing session cookie, then Spark will return that 
  existing session and not create a new one. This can create a security vulnerability if an attacker is able 
  to inject their own session cookie into another user’s web browser. Once the victim logs in, the API will 
  change the username attribute in the session from the attacker’s username to the victim’s username.
  The attacker’s session token now allows them to access the victim’s account

DEFINITION
 Sub-domain hijacking (or sub-domain takeover) occurs when an attacker is able to claim an abandoned web host that 
 still has valid DNS records configured. This typically occurs when a temporary site is created on a shared 
 service like GitHub Pages and configured as a sub-domain of the main website. When the site is no longer 
 required, it is deleted but the DNS records are often forgotten. An attacker can discover these DNS records 
 and re-register the site on the shared web host, under the attacker's control. They can then serve their 
 content from the compromised sub-domain.

Some browsers also support naming conventions for cookies: 
  __Secure- Enforces that the cookie must be set with the Secure attribute and set by a secure origin.
  __Host-  Enforces the same protections as __Secure-, but also enforces that the cookie is a host-only 
   cookie (has no Domain attribute). This ensures that the cookie cannot be overwritten by a cookie from a 
   sub-domain and is a significant protection against sub-domain hijacking attacks.
NOTE: These prefixes start with two underscore characters and include a hyphen at the end. For example, 
      if your cookie was previously named “session,” then the new name with the host prefix: “__Host-session.”

  Cross-Site Request Forgery attacks
In many cases browsers will happily let a script from another website make cross-origin requests to your 
  API; it just prevents them from reading any response. Such an attack is known as Cross-Site Request 
  Forgery because the malicious site can create fake requests to your API that appear to come from a
  genuine client.
DEFINITION Cross-site request forgery (CSRF, pronounced “sea-surf”) occurs when an attacker makes a 
  cross-origin request to your API and the browser sends cookies along with the request. The request is 
  processed as if it was genuine unless extra checks are made to prevent these requests.

  SameSite cookies
   When a cookie is marked as SameSite, it will only be sent on requests that originate from the same
   registerable domain that originally set the cookie. This means that when the malicious site from Polly’s 
   link tries to send a request to the Natter API, the browser will send it without the session cookie 
   and the request will be rejected by the server
DEFINITION
   A SameSite cookie will only be sent on requests that originate from the same domain that originally set 
   the cookie. Only the registerable domain is examined, so api.payments.example.com and www .example.com
   are considered the same site, as they both have the registerable domain of example.com. On the other hand, 
   www.example.org (different suffix) and www.different.com are considered different sites. Unlike an origin, 
   the protocol and port are not considered when making same-site decisions.

The public suffix list
  SameSite cookies rely on the notion of a registerable domain, which consists of a top-level domain plus 
  one more level. For example, .com is a top-level domain, so example.com is a registerable domain, but 
  foo.example.com typically isn't. The situ- ation is made more complicated because there are some domain 
  suffixes such as .co.uk, which aren’t strictly speaking a top-level domain (which would be .uk) but should 
  be treated as if they are. There are also websites like github.io that allow any- body to sign up and 
  register a sub-domain, such as neilmadden.github.io, making github.io also effectively a top-level domain.
  Because there are no simple rules for deciding what is or isn’t a top-level domain, Mozilla maintains an 
  up-to-date list of effective top-level domains (eTLDs), known as the public suffix list (https://publicsuffix.org).
  A registerable domain in SameSite is an eTLD plus one extra level, or eTLD + 1 for short. You can submit 
  your own website to the public suffix list if you want your sub-domains to be treated as effectively 
  independent websites with no cookie sharing between them, but this is quite a drastic measure to take.

To mark a cookie as SameSite, you can add either SameSite=lax or SameSite=strict on the Set-Cookie header, 
  just like marking a cookie as Secure or HttpOnly (section 4.3.2). The difference between the two modes 
  is subtle. In strict mode, cookies will not be sent on any cross-site request, including when a user just 
  clicks on a link from one site to another. This can be a surprising behavior that might break traditional 
  websites. To get around this, lax mode allows cookies to be sent when a user directly clicks on a link but 
  will still block cookies on most other cross-site requests. Strict mode should be preferred if you can 
  design your UI to cope with missing cookies when following links.
  For example, many single-page apps work fine in strict mode because the first request
  when following a link just loads a small HTML template and the JavaScript imple-
  menting the SPA. Subsequent calls from the SPA to the API will be allowed to include
  cookies as they originate from the same site.

DEFINITION
  SHA-256 is a cryptographically secure hash function designed by the US National Security Agency that 
  produces a 256-bit (32-byte) output value. SHA-256 is one variant of the SHA-2 family of secure hash algorithms
  specified in the Secure Hash Standard (https://doi.org/10.6028/NIST.FIPS .180-4), which replaced the older 
  SHA-1 standard (which is no longer considered secure). SHA-2 specifies several other variants that produce 
  different output sizes, such as SHA-384 and SHA-512. There is also now a newer SHA-3 standard (selected 
  through an open international competition), with variants named SHA3-256, SHA3-384, and so on, but SHA-2 
  is still considered secure and is widely implemented.

Timing attacks
  A timing attack works by measuring tiny differences in the time it takes a computer to process different inputs
  to work out some information about a secret value that the attacker does not know. Timing attacks can measure 
  even very small differences in the time it takes to perform a computation, even when carried out over the 
  internet. The classic paper Remote Timing Attacks are Practical by David Brumley and Dan Boneh of Stanford 
  (2005; https://crypto.stanford.edu/~dabo/papers/ssl-timing.pdf) demonstrated that timing attacks are practical 
  for attacking computers on the same local network, and the techniques have been developed since then. Recent
  research shows you can remotely measure timing differences as low as 100 nanoseconds over the internet 
  (https://papers.mathyvanhoef.com/usenix2020.pdf). Consider what would happen if you used the normal String 
  equals method to compare the hash of the session ID with the anti-CSRF token received in a header. In most 
  programming languages, including Java, string equality is implemented with a loop that terminates as soon as 
  the first non-matching character is found. This means that the code takes very slightly longer to match if 
  the first two characters match than if only a single character matches. A sophisticated attacker can measure 
  even this tiny difference in timing. They can then simply keep sending guesses for the anti-CSRF token. First, 
  they try every possible value for the first character (64 possibilities because we are using base64-encoding) 
  and pick the value that took slightly longer to respond. Then they do the same for the second character, 
  and then the third, and so on. By finding the character that takes slightly longer to respond at each step, 
  they can slowly recover the entire anti-CSRF token using time only proportional to its length, rather than 
  needing to try every possible value. For a 10-character Base64-encoded string, this changes the number of 
  guesses needed from around 64 10 (over 1 quintillion possibilities) to just 640. Of course, this attack 
  needs many more requests to be able to accurately measure such small timing differences (typically many 
  thousands of requests per character), but the attacks are improving all the time. The solution to such 
  timing attacks is to ensure that all code that performs comparisons or lookups using secret values take a 
  constant amount of time regardless of the value of the user input that is supplied. To compare two strings 
  for equality, you can use a loop that does not terminate early when it finds a wrong value. The following 
  code uses bitwise XOR (^) and OR (|) operators to check if two strings are equal. The value of c will only 
  be zero at the end if every single character was identical. 
    if (a.length != b.length) return false;
      int c = 0;
    for (int i = 0; i < a.length; i++)
      c |= (a[i] ^ b[i]);
    return c == 0;
  This code is very similar to how MessageDigest.isEqual is implemented in Java. Check the documentation 
  for your programming language to see if it offers a similar facility.


DEFINITION
  A preflight request occurs when a browser would normally block the request for violating the same-origin 
  policy. The browser makes an HTTP OPTIONS request to the server asking if the request should be allowed. The
  server can either deny the request or else allow it with restrictions on the allowed headers and methods.

The browser first makes an HTTP OPTIONS request to the target server. It includes the origin of the script 
  making the request as the value of the Origin header, along with some headers indicating the HTTP method 
  of the method that was requested (Access-Control-Request-Method header) and any nonstandard headers that 
  were in the original request (Access-Control-Request-Headers). The server responds by sending back a 
  response with headers to indicate which cross-origin requests it considers acceptable. If the original 
  request does not match the server’s response, or the server does not send any CORS headers in the response,
  then the browser blocks the request. If the original request is allowed, the API can also set CORS headers 
  in the response to that request to control how much of the response is revealed to the client. An API might 
  therefore agree to allow cross-origin requests with nonstandard headers but prevent the client from 
  reading the response

 ╒═══════════════════════════════════════════════════════════════════════════════════╕
    Because cookies are considered a credential by CORS, you need to return an     
     Access-Control-Allow-Credentials: true header from preflight requests; otherwise, 
     the browser will not send the session cookie.                                     
 └───────────────────────────────────────────────────────────────────────────────────┘


CORS and SameSite cookies
  SameSite cookies, described in chapter 4, are fundamentally incompatible with CORS. If a cookie is marked 
  as SameSite, then it will not be sent on cross-site requests regardless of any CORS policy and the 
  Access-Control-Allow-Credentials header is ignored. An exception is made for origins that are sub-domains 
  of the same site; for example, www.example.com can still send requests to api.example.com, but genuine 
  cross-site requests to different registerable domains are disallowed. If you need to allow cross-site 
  requests with cookies, then you should not use SameSite cookies.

TIP
  If you want scripts from two sibling sub-domains to share storage, you can set the document.domain field 
  to a common parent domain in both scripts. Both scripts must explicitly set the document.domain, otherwise 
  it will be ignored. For example, if a script from a.example.com and a script from b.example.com both set 
  document.domain to example.com, then they will share Web Storage. This is allowed only for a valid parent 
  domain of the script origin, and you cannot set it to a top-level domain like .com or .org. Setting the 
  document.domain field also instructs the browser to ignore the port when comparing origins.


DEFINITION
  Exfiltration is the act of stealing tokens and sensitive data from a page and sending them to the attacker 
  without the victim being aware. The attacker can then use the stolen tokens to log in as the user from 
  the attacker’s own device.

  If an attacker can exploit an XSS attack (chapter 2) against a browser-based client of your API, then 
   they can easily loop through the contents of Web Storage and create an img tag for each item with the 
   src attribute, pointing to an attacker-controlled website to extract the contents, as illustrated in 
   figure 5.5. Most browsers will eagerly load an image source URL, without the img even being added to 
   the page, 4 allowing the attacker to steal tokens covertly with no visible indication to the user.

DEFINITION
  A message authentication code (MAC) is an algorithm for computing a short fixed-length authentication 
  tag from a message and a secret key. A user with the same secret key will be able to compute the same 
  tag from the same message, but any change in the message will result in a completely different tag. An 
  attacker without access to the secret cannot compute a correct tag for any message. HMAC (hash-based MAC) 
  is a widely used secure MAC based on a cryptographic hash function. For example, HMAC-SHA-256 is
  HMAC using the SHA-256 hash function.


Java supports loading keys from keystores using the java.security.KeyStore class, and you can create 
  a keystore using the keytool command shipped with the JDK. Java provides several keystore formats, 
  but you should use the PKCS #12 format (https://tools.ietf.org/html/rfc7292) because that is the 
  most secure option supported by keytool.

Encrypting database attributes
  One way to protect sensitive attributes in the database is by encrypting them. While many databases 
  come with built-in support for encryption, and some commercial products can add this, these solutions 
  typically only protect against attackers that gain access to the raw database file storage. Data 
  returned from queries is transparently decrypted by the database server, so this type of encryption 
  does not protect against SQL injection or other attacks that target the database API. You can solve
  this by encrypting database records in your API before sending data to the database, and then 
  decrypting the responses read from the database.


  JSON Web Tokens
  A standard header format that contains metadata about the JWT, such as which
   MAC or encryption algorithm was used.
  A set of standard claims that can be used in the JSON content of the JWT, with defined meanings, such 
   as exp to indicate the expiry time and sub for the subject, just as you have been using.
  A wide range of algorithms for authentication and encryption, as well as digital signatures and 
   public key encryption that are covered later in this book.

The JWT standards zoo
  While JWT itself is just one specification (https://tools.ietf.org/html/rfc7519), it builds on a collection 
  of standards collectively known as JSON Object Signing and Encryption (JOSE). JOSE itself consists of 
  several related standards:
    JSON Web Signing (JWS, https://tools.ietf.org/html/rfc7515) defines how JSON objects can be 
     authenticated with HMAC and digital signatures.
    JSON Web Encryption (JWE, https://tools.ietf.org/html/rfc7516) defines how to encrypt JSON objects.
    JSON Web Key (JWK, https://tools.ietf.org/html/rfc7517) describes a standard format 
     for cryptographic keys and related metadata in JSON.
    JSON Web Algorithms (JWA, https://tools.ietf.org/html/rfc7518) then specifies signing 
     and encryption algorithms to be used.
++ JOSE has been extended over the years by new specifications to add new algorithms
   and options. It is common to use JWT to refer to the whole collection of specifica-
   tions, although there are uses of JOSE beyond JWTs.

DEFINITION
   A replay attack occurs when an attacker captures a token sent by a
   legitimate party and later replays it on their own request.

  In JWT:  The issuer and audience claims can be used to prevent a different form of replay attack, in 
   which the captured token is replayed against a different API than the originally intended recipient. If 
   the attacker replays the token back to the original issuer, this is known as a reflection attack, and can 
   be used to defeat some kinds of authentication protocols if the recipient can be tricked into accepting 
   their own authentication messages. By verifying that your API server is in the audience list, and that the 
   token was issued by a trusted party, these attacks can be defeated.
   
╒═══════════════════════════════════════════════════════════════════════════════════════════════════════════╕
DEFINITION                                                                                                
  A headless JWT is a JWT with the header removed. The recipient recreates the header from expected values. 
  For simple use cases where you control the sender and recipient this can reduce the size and attack surface
  of using JWTs but the resulting JWTs are nonstandard. Where headless JWTs                                 
  can’t be used, you should strictly validate all header values.                                            
└───────────────────────────────────────────────────────────────────────────────────────────────────────────┘


DEFINITION
  Cryptographic agility is the ability to change the algorithm used for securing messages or tokens 
  in case weaknesses are discovered in one algorithm or a more performant alternative is required.

Although this is a good idea (Cryptographic agility), the design in JOSE is less than ideal because the 
  recipient must rely on the sender to tell them which algorithm to use to authenticate the message. This 
  violates the principle that you should never trust a claim that you have not authenticated, and yet you 
  cannot authenticate the JWT until you have processed this claim! This weakness was what allowed Tim McClean 
  to confuse JWT libraries by changing the alg header.

DEFINITION
  Key rotation is the process of periodically changing the keys used to protect messages and tokens. 
  Changing the key regularly ensures that the usage limits for a key are never reached and if any one 
  key is compromised then it is soon replaced, limiting the time in which damage can be done.

  There are several secure encryption algorithms in current use, but the most important is the Advanced 
   Encryption Standard (AES), which was standardized in 2001 after an international competition, and is 
   widely considered to be very secure. AES is an example of a block cipher, which takes a fixed size input 
   of 16 bytes and produces a 16-byte encrypted output. AES keys are either 128 bits, 192 bits, or 256 bits 
   in size. To encrypt more (or less) than 16 bytes with AES, you use a block cipher mode of operation.

Authenticated encryption
   Many encryption algorithms only ensure the confidentiality of data that has been encrypted and don’t 
   claim to protect the integrity of that data. This means that an attacker won’t be able to read any 
   sensitive attributes in an encrypted token, but they may be able to alter them. For example, if you know 
   that a token is encrypted with CTR mode and (when decrypted) starts with the string user=brian, you can change
   this to read user=admin by simple manipulation of the ciphertext even though you can’t decrypt the token. 
   Although there isn’t room to go into the details here, this kind of attack is often covered in cryptography 
   tutorials under the name chosen ciphertext attack.
   To protect against spoofing and tampering threats, you should always use algorithms
   that provide authenticated encryption. Authenticated encryption algorithms combine an
   encryption algorithm for hiding sensitive data with a MAC algorithm, such as HMAC,
   to ensure that the data can’t be altered or faked.
++ DEFINITION Authenticated encryption combines an encryption algorithm with
   a MAC. Authenticated encryption ensures confidentiality and integrity of messages.


Authenticated encryption with NaCl
  Because cryptography is complex with many subtle details to get right, a recent trend has been for 
  cryptography libraries to provide higher-level APIs that hide many of these details from developers. 
  The most well-known of these is the Networking and Cryptography Library (NaCl; https://nacl.cr.yp.to) 
  designed by Daniel Bernstein. NaCl (pronounced “salt,” as in sodium chloride) provides high-level operations
  for authenticated encryption, digital signatures, and other cryptographic primitives but hides many of the 
  details of the algorithms being used. Using a high-level library designed by experts such as NaCl is the 
  safest option when implementing cryptographic protections for your APIs and can be significantly easier 
  to use securely than alternatives.
++ Other cryptographic libraries designed to be hard to misuse include Google’s Tink (github.com/google/tink)  
   and Themis from Cossack Labs (https://github.com/cossacklabs/themis). The Sodium library (libsodium.org) 
   is a widely used clone of NaCl in C that provides many additional extensions and a simplified API with 
   bindings for Java and other languages.


  The five components of a JWE are:
1 The JWE header, which is very like the JWS header, but with two additional fields: enc, which specifies 
  the encryption algorithm, and zip, which specifies an optional compression algorithm to be applied 
  before encryption. 
2 An optional encrypted key. This is used in some of the more complex encryption algorithms. It is empty 
  for the direct symmetric encryption algorithm that is covered in this chapter.
3 The initialization vector or nonce used when encrypting the payload. Depending on the encryption method 
  being used, this will be either a 12- or 16-byte random binary value that has been Base64url-encoded.
4 The encrypted ciphertext.
5 The MAC authentication tag.

DEFINITION
  An initialization vector (IV) or nonce (number-used-once) is a unique value that is provided to the cipher 
  to ensure that ciphertext is always different even if the same message is encrypted more than once. The IV
  should be generated using a java.security.SecureRandom or other cryptographically-secure pseudorandom 
  number generator (CSPRNG). 3 An IV doesn’t need to be kept secret.

-- JWE divides specification of the encryption algorithm into two parts:
  The enc header describes the authenticated encryption algorithm used to encrypt the payload of the JWE.
  The alg header describes how the sender and recipient agree on the key used to encrypt the content.


There are a wide variety of key management algorithms for JWE, but for this chapter you will stick to direct 
  encryption with a secret key. For direct encryption, the algorithm header is set to dir (direct). There are 
  currently two available families of encryption methods in JOSE, both of which provide authenticated encryption:
  A128GCM, A192GCM, and A256GCM use AES in Galois Counter Mode (GCM).
  A128CBC-HS256, A192CBC-HS384, and A256CBC-HS512 use AES in Cipher Block Chaining (CBC) mode together 
   with either HMAC in an EtM configuration as described in section 6.3.1.

  DEFINITION
   All the encryption algorithms allow the JWE header and IV to be included in the authentication tag 
   without being encrypted. These are known as authenticated encryption with associated data (AEAD) algorithms.

  GCM was designed for use in protocols like TLS where a unique session key is negotiated for each session 
   and a simple counter can be used for the nonce. If you reuse a nonce with GCM then almost all security 
   is lost: an attacker can recover the MAC key and use it to forge tokens, which is catastrophic for 
   authentication tokens. For this reason, I prefer to use CBC with HMAC for directly encrypted JWTs, but 
   for other JWE algorithms GCM is an excellent choice and very fast.


What key size should you use?
  AES allows keys to be in one of three different sizes: 128-bit, 192-bit, or 256-bit. In principle, correctly 
  guessing a 128-bit key is well beyond the capability of even an attacker with enormous amounts of computing 
  power. Trying every possible value of a key is known as a brute-force attack and should be impossible for 
  a key of that size. There are three exceptions in which that assumption might prove to be wrong: 
  A weakness in the encryption algorithm might be discovered that reduces the amount of effort required 
   to crack the key. Increasing the size of the key provides a security margin against such a possibility.
  New types of computers might be developed that can perform brute-force searches much quicker than existing 
   computers. This is believed to be true of quantum computers, but it’s not known whether it will ever be 
   possible to build a large enough quantum computer for this to be a real threat. Doubling the size of the 
   key protects against known quantum attacks for symmetric algorithms like AES.
  Theoretically, if each user has their own encryption key and you have millions of users, it may be possible
   to attack every key simultaneously for less effort than you would expect from naively trying to break them 
   one at a time. This is known as a batch attack and is described further in https://blog.cr.yp.to/20151120-batchattacks.html.
++ At the time of writing, none of these attacks are practical for AES, and for short-lived authentication 
   tokens the risk is significantly less, so 128-bit keys are perfectly safe. On the other hand, modern CPUs 
   have special instructions for AES encryption so there’s very little extra cost for 256-bit keys if you 
   want to eliminate any doubt.
++ Remember that the JWE CBC with HMAC methods take a key that is twice the size as normal. For example, 
   the A128CBC-HS256 method requires a 256-bit key, but this is really two 128-bit keys joined together 
   rather than a true 256-bit key.

  Compressed tokens
   The encrypted JWT is a bit larger than either a simple HMAC token or the NaCl tokens from section 6.3.2. 
   JWE supports optional compression of the JWT Claims Set before encryption, which can significantly reduce 
   the size for complex tokens. But combining encryption and compression can lead to security weaknesses. 
   Most encryption algorithms do not hide the length of the plaintext message that was encrypted, and 
   compression reduces the size of a message based on its content. For example, if two parts of a message are 
   identical, then it may combine them to remove the duplication. If an attacker can influence part of a 
   message, they may be able to guess the rest of the contents by seeing how much it compresses. The CRIME 
   and BREACH attacks (http://breachattack.com) against TLS were able to exploit this leak of information 
   from compression to steal session cookies from compressed HTTP pages. These kinds of attacks are not always 
   a risk, but you should carefully consider the possibility before enabling compression. Unless you really 
   need to save space, you should leave compression disabled.


  In some countries, banks are being required to provide secure API access to transactions and payment 
   services to third-party apps and services. The UK’s Open Banking initiative and the European Payment 
   Services Directive 2 (PSD2) regulations are examples, both of which mandate the use of OAuth2.

  The difference between scopes and permissions
   At first glance, it may seem that scopes and permissions are very similar, but there is a distinction in 
   what they are used for, Typically, an API is owned and operated by a central 
   authority such as a company or an organization. Who can access the API and what they are allowed to do 
   is controlled entirely by the central authority. This is an example of mandatory access control, because 
   the users have no control over their own permissions or those of other users. On the other hand, when a
   user delegates some of their access to a third-party app or service, that is known as discretionary access 
   control, because it’s up to the user how much of their access to grant to the third party. OAuth scopes are 
   fundamentally about discretionary access control, while traditional permissions (which you implemented using 
   ACLs in chapter 3) can be used for mandatory access control.

## OAuth uses specific terms to refer to the four entities shown in 
   figure 7.4, based on the role they play in the interaction:
  The authorization server (AS) authenticates the user and issues tokens to clients.
  The user is known as the resource owner (RO), because it’s typically their resources (documents, photos, and 
   so on) that the third-party app is trying to access. This term is not always accurate, but it has stuck now.
  The third-party app or service is known as the client.
  The API that hosts the user’s resources is known as the resource server (RS).

There are two different types of clients in OAuth:
  Public clients are applications that run entirely within a user’s own device, such as a mobile app 
   or JavaScript client running in a browser. The client is completely under the user’s control.
  Confidential clients run in a protected web server or other secure location that is not under 
   a user’s direct control.

  The Authorization Code grant
-- the authorization code grant is the preferred way for almost all client types to 
   obtain an access token, including the following:
  Server-side clients, such as traditional web applications or other APIs. A serverside application 
   should be a confidential client with credentials to authenticate to the AS.
  Client-side JavaScript applications that run in the browser, such as single-page apps. A client-side 
   application is always a public client because it has no secure place to store a client secret.
  Mobile, desktop, and command-line applications. As for client-side applica- tions, these should be 
   public clients, because any secret embedded into the application can be extracted by a user.


  DEFINITION
   An open redirect vulnerability is when a server can be tricked into redirecting a web browser to a URI 
   under the attacker’s control. This can be used for phishing because it initially looks like the user is 
   going to a trusted site, only to be redirected to the attacker. You should require all redirect URIs to be 
   pre-registered by trusted clients rather than redirecting to any URI provided in a request.

  Hardening code exchange with PKCE
   Before the invention of claimed HTTPS redirect URIs, mobile applications using private-use URI schemes were 
   vulnerable to code interception by a malicious app registering the same URI scheme, as described in the 
   previous section. To protect against this attack, the OAuth working group developed the PKCE standard 
   (Proof Key for Code Exchange; https://tools.ietf.org/html/rfc7636), pronounced “pixy.” Since then, formal 
   analysis of the OAuth protocol has identified a few theoretical attacks against the authorization code flow. 
   For example, an attacker may be able to obtain a genuine authorization code by interacting with a legitimate 
   client and then using an XSS attack against a victim to replace their authorization code with the attacker’s. 
   Such an attack would be quite difficult to pull off but is theoretically possible. It’s therefore recommended 
   that all types of clients use PKCE to strengthen the authorization code flow.


DEFINITION
  A client can use a refresh token to obtain a fresh access token when the original one expires. This allows an 
  AS to issue short-lived access tokens without clients having to ask the user for a new token every time it expires.


TLS cipher suites
  For example, the TLS 1.2 cipher suite TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 specifies that the two parties 
  will use the Elliptic Curve Diffie-Hellman (ECDH) key agreement algorithm (using ephemeral keys, indicated 
  by the final E), with RSA signatures for authentication, and the agreed session key will be used to encrypt 
  messages using AES in Galois/Counter Mode. (SHA-256 is used as part of the key agreement.)
  In TLS 1.3, cipher suites only specify the block cipher and hash function used, such as 
  TLS_AES_128_GCM_SHA256. The key exchange and authentication algorithms are negotiated separately.

DEFINITION
  A cipher suite offers forward secrecy if the confidentiality of data transmitted using that cipher suite 
  is protected even if one or both of the parties are compromised afterwards. All cipher suites provide 
  forward secrecy in TLS 1.3. In TLS 1.2, these cipher suites start with TLS_ECDHE_ or TLS_DHE_.

Certificate chains
  When configuring the trust store for your HTTPS client, you could choose to directly trust the server 
  certificate for that server. Although this seems more secure, it means that whenever the server changes 
  its certificate, the client would need to be updated to trust the new one. Many server certificates are 
  valid for only 90 days. If the server is ever compromised, then the client will continue trusting the 
  compromised certificate until it’s manually updated to remove it from the trust store. To avoid these 
  problems, the server certificate is signed by a CA, which itself has a (self-signed) certificate. When a 
  client connects to the server it receives the server’s current certificate during the handshake. To verify 
  this certificate is genuine, it looks up the corresponding CA certificate in the client trust store and 
  checks that the server certificate was signed by that CA and is not expired or revoked. In practice, the 
  server certificate is often not signed directly by the CA. Instead, the CA signs certificates for one or 
  more intermediate CAs, which then sign server certificates. The client may therefore have to verify a 
  chain of certificates until it finds a certificate of a root CA that it trusts directly. Because CA 
  certificates might themselves be revoked or expire, in general the client may have to consider multiple 
  possible certificate chains before it finds a valid one. Verifying a certificate chain is complex and 
  error-prone with many subtle details so you should always use a mature library to do this.


  Of these choices (Table 7.2 JWS signature algorithms), the best is EdDSA, based on the Edwards Curve 
   Digital Signature Algorithm (https://tools.ietf.org/html/rfc8037). EdDSA signatures are fast to produce 
   and verify, produce compact signatures, and are designed to be implemented securely against side-channel 
   attacks. Not all JWT libraries or AS software supports EdDSA signatures yet. The older ECDSA standard for 
   elliptic curve digital signatures has wider support, and shares some of the same properties as EdDSA, 
   but is slightly slower and harder to implement securely.
++  WARNING
    ECDSA signatures require a unique random nonce for each signature. If a nonce is repeated, or even just a 
    few bits are not completely random, then the private key can be reconstructed from the signature values. 
    This kind of bug was used to hack the Sony PlayStation 3, steal Bitcoin cryptocurrency from wallets on 
    Android mobile phones, among many other cases. Deterministic ECDSA signatures (tools.ietf.org/html/rfc6979) 
    can be used to prevent this, if your library supports them. EdDSA signatures are also immune to this issue.

 ╒════════════════════════════════════════════════════════════════════════════════════════════════════════════╕
     RSA signatures are expensive to produce, especially for secure key sizes (a 3072-bit RSA key is roughly 
      equivalent to a 256-bit elliptic curve key or a 128-bit HMAC key) and produce much larger signatures       
      than the other options, resulting in larger JWTs. On the other hand, RSA signatures can be validated very  
      quickly. The variants of RSA using PSS padding should be preferred over those using the older PKCS#1       
      version 1.5 padding but may not be supported by all libraries.                                             
 └────────────────────────────────────────────────────────────────────────────────────────────────────────────┘


  OpenID Connect
   OAuth can provide basic SSO functionality, but the primary focus is on delegated third-party access to APIs 
   rather than user identity or session management. The OpenID Connect (OIDC) suite of standards 
   (https://openid.net/developers/specs/) extend OAuth2 with several features:
-- A standard way to retrieve identity information about a user, such as their name, email address, postal 
   address, and telephone number. The client can access a UserInfo endpoint to retrieve identity claims as 
   JSON using an OAuth2 access token with standard OIDC scopes.
-- A way for the client to request that the user is authenticated even if they have an existing session, and 
   to ask for them to be authenticated in a particular way, such as with two-factor authentication. While 
   obtaining an OAuth2 access token may involve user authentication, it’s not guaranteed that the user was 
   even present when the token was issued or how recently they logged in. OAuth2 is primarily a delegated 
   access protocol, whereas OIDC provides a full authentication protocol. If the client needs to positively 
   authenticate a user, then OIDC should be used.
-- Extensions for session management and logout, allowing clients to be notified when a user logs out of 
   their session at the AS, enabling the user to log out of all clients at once (known as single logout).


  The LDAP standard defines the following two forms of groups
1- Static groups are defined using the groupOfNames or groupOfUniqueNames object classes, which explicitly 
   list the members of the group using the member or uniqueMember attributes. The difference between the two 
   is that groupOfUniqueNames forbids the same member being listed twice.
2- Dynamic groups are defined using the groupOfURLs object class, where the membership of the group is 
   given by a collection of LDAP URLs that define search queries against the directory. Any entry that 
   matches one of the search URLs is a member of the group.


  Role-based access control
   In principle, everything that you can accomplish with RBAC could be accomplished with groups, but in practice 
   there are several differences in how they are used, including the following:
  Groups are used primarily to organize users, while roles are mainly used as a way to organize permissions.
  As discussed in the previous section, groups tend to be assigned centrally, whereas roles tend to be 
   specific to a particular application or API. As an example, every API may have an admin role, but the 
   set of users that are administrators may differ from API to API.
  Group-based systems often allow permissions to be assigned to individual users, but RBAC systems typically 
   don’t allow that. This restriction can dramatically simplify the process of reviewing who has access to what.
  RBAC systems split the definition and assigning of permissions to roles from the assignment of users to 
   those roles. It is much less error-prone to assign a user to a role than to work out which permissions 
   each role should have, so this is a useful separation of duties that improves security.
  Roles may have a dynamic element. For example, some military and other environments have the concept of 
   a duty officer, who has particular privileges and responsibilities only during their shift. When the shift 
   ends, they hand over to the next duty officer, who takes on that role.

   
  Attribute-based access control. In ABAC, access control decisions are made dynamically for each API 
   request using collections of attributes grouped into four categories:
  Attributes about the subject; that is, the user making the request. This could include their username, 
   any groups they belong to, how they were authenticated, when they last authenticated, and so on.
  Attributes about the resource or object being accessed, such as the URI of the
   resource or a security label (TOP SECRET, for example).
  Attributes about the action the user is trying to perform, such as the HTTP method.
  Attributes about the environment or context in which the operation is taking place. This might include 
   the local time of day, or the location of the user performing the action.


-- To maximize the benefits of ABAC while limiting the potential for mistakes, con-
   sider adopting the following best practices:
  Layer ABAC over a simpler access control technology such as RBAC. This provides a defense-in-depth 
   strategy so that a mistake in the ABAC rules doesn’t result in a total loss of security.
  Implement automated testing of your API endpoints so that you are alerted quickly if a policy 
   change results in access being granted to unintended parties.
  Ensure access control policies are maintained in a version control system so that they can be 
   easily rolled back if necessary. Ensure proper review of all policy changes.
  Consider which aspects of policy should be centralized and which should be left up to individual 
   APIs or local policy agents. Though it can be tempting to cen- tralize everything, this can introduce 
   a layer of bureaucracy that can make it harder to make changes. In the worst case, this can violate 
   the principle of least privilege because overly broad policies are left in place due to the overhead 
   of changing them.
  Measure the performance overhead of ABAC policy evaluation early and often.


DEFINITION
  A confused deputy attack occurs when a component of a system with elevated privileges can be tricked by 
  an attacker into carrying out actions that the attacker themselves would not be allowed to perform. The 
  CSRF attacks of chapter 4 are classic examples of confused deputy attacks, where the web browser is tricked 
  into carrying out the attacker’s requests using the victim’s session cookie.


Capability-based security
  A capability is an unforgeable reference to an object or resource together with a set of permissions to 
  access that resource. To illustrate how capability-based security differs from identity-based security, 
  consider the following two ways to copy a file on UNIX 1 systems:
  cp a.txt b.txt
  cat <a.txt >b.txt
-- The first, using the cp command, takes as input the name of the file to copy and the name of the file to 
   copy it to. The second, using the cat command, instead takes as input two file descriptors: one opened for 
   reading and the other opened for writing. It then simply reads the data from the first file descriptor and 
   writes it to the second. If you think about the permissions that each of these commands needs, the cp com-
   mand needs to be able to open any file that you can name for both reading and writing. To allow this, UNIX runs 
   the cp command with the same permissions as your own user account, so it can do anything you can do, including 
   deleting all your files and emailing your private photos to a stranger. This violates POLA because the command 
   is given far more permissions than it needs. The cat command, on the other hand, just needs to read from its 
   input and write to its output. It doesn’t need any permissions at all (but of course UNIX gives it all your 
   permissions anyway). A file descriptor is an example of a capability, because it combines a reference to some 
   resource along with a set of permissions to act on that resource.

-- capabilities have several differences compared to other identity-based access control techniques: 
  Access to resources is via unforgeable references to those objects that also grant authority to access 
   that resource. In an identity-based system, anybody can attempt to access a resource, but they might be 
   denied access depending on who they are. In a capability-based system, it is impossible to send a request 
   to a resource if you do not have a capability to access it. For example, it is impossible to write to a 
   file descriptor that your process doesn’t have. You’ll see in section 9.2 how this is implemented for REST APIs.
  Capabilities provide fine-grained access to individual resources, and often support POLA more naturally 
   than identity-based systems. It is much easier to delegate a small part of your authority to somebody 
   else by giving them some capabilities without giving them access to your whole account. 
  The ability to easily share capabilities can make it harder to determine who has access to which resources 
   via your API. In practice this is often true for identity-based systems too, as people share access in 
   other ways (such as by sharing passwords).
  Some capability-based systems do not support revoking capabilities after they have been granted. When 
   revocation is supported, revoking a widely shared capability may deny access to more people than was intended.

DEFINITION
  When the permission to perform an action is automatically granted to all requests that originate from a 
  given environment this is known as ambient authority. Examples of ambient authority include session cookies
  and allowing access based on the IP address a request comes from. Ambient authority increases the risks 
  of confused deputy attacks and should be avoided whenever possible.

DEFINITION
  A capability URI (or capability URL) is a URI that both identifies a resource and conveys a set of 
  permissions to access that resource. Typically, a capability URI encodes an unguessable token into some 
  part of the URI structure (e.g links sent in password reset emails).

Credentials in URIs: A lesson from history
  The desire to share access to private resources simply by sharing a URI is not new. For a long time, 
  browsers supported encoding a username and password into a HTTP URL in the form 
  http://alice:secret@example.com/resource. When such a link was clicked, the browser would send the username 
  and password using HTTP Basic authentication (see chapter 3). Though convenient, this is widely considered 
  to be a security disaster. For a start, sharing a username and password provides full access to your account 
  to anybody who sees the URI. Secondly, attackers soon realized that this could be used to create convincing 
  phishing links such as http://www.google.com:80@evil.example.com/login.html. An unsuspecting user would see 
  the google.com domain at the start of the link and assume it was genuine, when in fact this is just a 
  username and they will really be sent to a fake login page on the attacker’s site. To prevent these attacks,
  browser vendors have stopped supporting this URI syntax and most now aggressively remove login information 
  when displaying or following such links. Although capability URIs are significantly more secure than directly 
  sharing a password, you should still be aware of any potential for misuse if you display URIs to users.

CAPABILITY URIS FOR REST APIS
  The drawbacks of capability URIs just mentioned apply when they are used as a means of navigating a 
  website. When capability URIs are used in a REST API many of these issues don’t apply:
  
  The Referer header and window.referrer variables are populated by browsers when a user directly navigates 
   from one web page to another, or when one page is embedded into another in an iframe. Neither of these 
   apply to the typical JSON responses from an API because these are not directly rendered as pages.
  Similarly, because users don’t typically navigate directly to API endpoints, these URIs will not end up 
   in the browser history. 
  API URIs are also unlikely to be bookmarked or otherwise saved for a long period of time. Typically, a 
   client knows a few permanent URIs as entry points to an API and then navigates to other URIs as it 
   accesses resources. These resource URIs can use short-lived tokens to mitigate against tokens being 
   leaked in access logs.


PRINCIPLE
  HATEOAS, or hypertext as the engine of application state, is a central principle of REST API design that 
  states that a client should not need to have specific knowledge of how to construct URIs to access your API. 
  Instead, the server should provide this information in the form of hyperlinks and form templates.

DEFINITION
  A macaroon is a type of cryptographic token that can be used to represent capabilities and other 
  authorization grants. Anybody can append new caveats to a macaroon that restrict how it can be used.

DEFINITION
  A contextual caveat is a caveat that is added by a client just before use. Contextual caveats allow the 
  authority of a token to be restricted before sending it over an insecure channel or to an untrusted API, 
  limiting the damage that might occur if the token is stolen.

