## There are several popular approaches to exposing remote APIs:
  The gRPC framework from Google (https://grpc.io) is an example of a modern RPC approach. The older 
   SOAP (Simple Object Access Protocol) framework, which uses XML for messages, is still widely deployed.
  A variant of the RPC style known as Remote Method Invocation (RMI) uses object-oriented techniques to 
   allow clients to call methods on remote objects as if they were local. RMI approaches used to be very 
   popular, with technologies such as CORBA and Enterprise Java Beans (EJBs) often used for building large
   enterprise systems The complexity of these frameworks has led to a decline in their use
j The REST (REpresentational State Transfer) style was developed by Roy Fielding to describe the principles 
   that led to the success of HTTP and the web and was later adapted as a set of principles for API design. 
   In contrast to RPC, RESTful APIs emphasize standard message formats and a small number of generic operations
   to reduce the coupling between a client and a specific API. Use of hyperlinks to
   navigate the API reduce the risk of clients breaking as the API evolves over time.


== if your APIs are serving requests on port 80 (for HTTP) and 443 (for HTTPS), then the firewall would be 
   configured to block any requests for any other ports. A load balancer will then route traffic to appropriate 
   services and ensure that one server is not overloaded with lots of requests while others sit idle. Finally, 
   a reverse proxy (or gateway) is typically placed in front of the application servers to perform computationally 
   expensive operations like handling TLS encryption (known as SSL termination) and validating credentials on requests.

== SSL termination1 (or SSL offloading) occurs when a TLS connection from a client is handled by a load 
   balancer or reverse proxy in front of the destination API server. A separate connection from the proxy to 
   the backend server is then made, which may either be unencrypted (plain HTTP) or encrypted as a separate 
   TLS connection (known as SSL re-encryption).

  An API gateway is a specialized reverse proxy that can make different APIs appear as if they are a single 
   API. They are often used within a microservices architecture to simplify the API presented to clients. 
   API gateways can often also take care of some of the aspects of API security discussed in this book, such 
   as authentication or rate-limiting.
  A web application firewall (WAF) inspects traffic at a higher level than a traditional firewall and can 
   detect and block many common attacks against HTTP web services.
  An intrusion detection system (IDS) or intrusion prevention system (IPS) monitors traffic within your internal 
   networks. When it detects suspicious patterns of activity it can either raise an alert or actively attempt 
   to block the suspicious traffic.


The most famous of these (standard security goals) are the so-called “CIA Triad”:
  Confidentiality—Ensuring information can only be read by its intended audience
  Integrity —Preventing unauthorized creation, modification, or destruction of information
  Availability —Ensuring that the legitimate users of an API can access it when
   they need to and are not prevented from doing so.


STRIDE, which stands for:
  Spoofing—Pretending to be somebody else
  Tampering—Altering data, messages, or settings you’re not supposed to alter
  Repudiation—Denying that you did something that you really did do
  Information disclosure—Revealing information that should be kept private
  Denial of service—Preventing others from accessing information and services
  Elevation of privilege—Gaining access to functionality you’re not supposed to have access to


There are many cases in which you are evaluating code that may not be as obvious as calling an
  explicit eval function, such as:
  Building an SQL command or query to send to a database
  Running an operating system command
  Performing a lookup in an LDAP directory
  Sending an HTTP request to another API
  Generating an HTML page to send to a web browser


Header and log injection
  There are examples of injection vulnerabilities that do not involve code being executed at all. For example,
  HTTP headers are lines of text separated by carriage return and new line characters ("\r\n" in Java). If 
  you include unvalidated user input in a HTTP header then an attacker may be able to add a "\r\n" character 
  sequence and then inject their own HTTP headers into the response. The same can happen when you include 
  user-controlled data in debug or audit log messages (see chapter 3), allowing an attacker to inject fake 
  log messages into the log file to confuse somebody later attempting to investigate an attack.

== A buffer overflow might seem harmless enough; it just corrupts some memory, so maybe we get an invalid 
   value in a variable, right? However, the memory that is overwritten may not always be simple data and, 
   in some cases, that memory may be inter- preted as code, resulting in a remote code execution vulnerability. 
   Such vulnerabilities are extremely serious, as the attacker can usually then run code in your process 
   with the full permissions of your legitimate code.

Insecure deserialization
  Although Java is a memory-safe language and so less prone to buffer overflow attacks, that does not mean 
  it is immune from RCE attacks. Some serialization libraries that convert arbitrary Java objects to and 
  from string or binary formats have turned out to be vulnerable to RCE attacks, known as an insecure 
  deserialization vulnerability in the OWASP Top 10. This affects Java’s built-in Serializable framework, 
  but also parsers for supposedly safe formats like JSON have been vulnerable, such as the popular Jackson 
  Databind. a The problem occurs because Java will execute code within the default constructor of any object 
  being deserialized by these frameworks.  Some classes included with popular Java libraries perform dangerous operations in
  their constructors, including reading and writing files and performing other actions. Some classes can even 
  be used to load and execute attacker-supplied bytecode directly. Attackers can exploit this behavior by 
  sending a carefully crafted message that causes the vulnerable class to be loaded and executed.
  The solution to these problems is to allowlist a known set of safe classes and refuse to deserialize any 
  other class. Avoid frameworks that do not allow you to control which classes are deserialized. Consult the 
  OWASP Deserialization Cheat Sheet for advice on avoid insecure deserialization vulnerabilities in several 
  programming languages: https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html.

== Powerful, regular expressions can themselves be a source of attack. Some regular expression 
   implementations can be made to consume large amounts of CPU time when processing certain inputs,
   leading to an attack known as a regular expression denial of service (ReDoS) attack
  
ReDoS Attacks
  A regular expression denial of service (or ReDoS) attack occurs when a regular expression can be forced 
  to take a very long time to match a carefully chosen input string. This can happen if the regular 
  expression implementation can be forced to back-track many times to consider different possible ways 
  the expression might match. As an example, the regular expression ^(a|aa)+$ can match a long string of 
  a characters using a repetition of either of the two branches. Given the input string “aaaaaaaaaaaaab” 
  it might first try matching a long sequence of single a characters, then when that fails (when it sees the 
  b at the end) it will try matching a sequence of single a characters followed by a double-a (aa) sequence,
  then two double-a sequences, then three, and so on. After it has tried all those it might try interleaving
  single-a and double-a sequences, and so on. There are a lot of ways to match this input, and so the pattern 
  matcher may take a very long time before it gives up. Some regular expression implementations are smart 
  enough to avoid these problems, but many popular programming languages (including Java) are not.a Design 
  your regular expressions so that there is always only a single way to match any input. In any repeated part 
  of the pattern, each input string should only match one of the alternatives. If you’re not sure, 
  prefer using simpler string operations instead.
  

Cross-Site Scripting
  Cross-site scripting, or XSS, is a common vulnerability affecting web applications, in
  which an attacker can cause a script to execute in the context of another site. In a
  persistent XSS, the script is stored in data on the server and then executed whenever
  a user accesses that data through the web application. A reflected XSS occurs when
  a maliciously crafted input to a request causes the script to be included (reflected)
  in the response to that request. Reflected XSS is slightly harder to exploit because a
  victim has to be tricked into visiting a website under the attacker’s control to trigger
  the attack. A third type of XSS, known as DOM-based XSS, attacks JavaScript code
  that dynamically creates HTML in the browser.
  These can be devastating to the security of a web application, allowing an attacker
  to potentially steal session cookies and other credentials, and to read and alter data
  in that session. To appreciate why XSS is such a risk, you need to understand that
  the security model of web browsers is based on the same-origin policy (SOP). Scripts
  executing within the same origin (or same site) as a web page are, by default, able
  to read cookies set by that website, examine HTML elements created by that site,
  make network requests to that site, and so on, although scripts from other origins
  are blocked from doing those things. A successful XSS allows an attacker to execute
  their script as if it came from the target origin, so the malicious script gets to do all
  the same things that the genuine scripts from that origin can do. If I can successfully
  exploit an XSS vulnerability on facebook.com, for example, my script could potentially
  read and alter your Facebook posts or steal your private messages.
  Although XSS is primarily a vulnerability in web applications, in the age of single-page
  apps (SPAs) it’s common for web browser clients to talk directly to an API. For this
  reason, it’s essential that an API take basic precautions to avoid producing output
  that might be interpreted as a script when processed by a web browser.

NOTE
  The XSS protections in browsers have been found to cause security vulnerabilities of their own in some 
  cases. The OWASP project now recom mends always disabling the filter with 
  the X-XSS-Protection: 0 header as shown previously.


In a DNS amplification attack, the attacker sends the same DNS query to many DNS servers, spoofing their 
  IP address to look like the request came from the victim. By carefully choosing the DNS query, the 
  server can be tricked into replying with much more data than was in the original query, flooding 
  the victim with traffic

Adding a HSTS header for localhost is not a good idea as it will prevent you from running development servers 
  over plain HTTP until the max-age attribute expires. If you want to try it out, set a short max-age value.

In a production environment you typically will want to send audit logs to a centralized log collection and 
  analysis tool, known as a SIEM (Security Information and Event Management) system, so they can be 
  correlated with logs from other systems and analyzed for potential threats and unusual behavior.

DEFINITION 
  A privilege escalation (or elevation of privilege) occurs when a user with limited permissions can exploit 
  a bug in the system to grant themselves or somebody else more permissions than they have been granted.

Session fixation attacks
  After the user authenticates, the CookieTokenStore then asks for a new session by calling 
  request.session(true). If the request did not have an existing session cookie, then this will create a 
  new session. But if the request already contains an existing session cookie, then Spark will return that 
  existing session and not create a new one. This can create a security vulnerability if an attacker is able 
  to inject their own session cookie into another user’s web browser. Once the victim logs in, the API will 
  change the username attribute in the session from the attacker’s username to the victim’s username.
  The attacker’s session token now allows them to access the victim’s account

DEFINITION
 Sub-domain hijacking (or sub-domain takeover) occurs when an attacker is able to claim an abandoned web host that 
 still has valid DNS records configured. This typically occurs when a temporary site is created on a shared 
 service like GitHub Pages and configured as a sub-domain of the main website. When the site is no longer 
 required, it is deleted but the DNS records are often forgotten. An attacker can discover these DNS records 
 and re-register the site on the shared web host, under the attacker's control. They can then serve their 
 content from the compromised sub-domain.

Some browsers also support naming conventions for cookies: 
  __Secure- Enforces that the cookie must be set with the Secure attribute and set by a secure origin.
  __Host-  Enforces the same protections as __Secure-, but also enforces that the cookie is a host-only 
   cookie (has no Domain attribute). This ensures that the cookie cannot be overwritten by a cookie from a 
   sub-domain and is a significant protection against sub-domain hijacking attacks.
NOTE: These prefixes start with two underscore characters and include a hyphen at the end. For example, 
      if your cookie was previously named “session,” then the new name with the host prefix: “__Host-session.”

  Cross-Site Request Forgery attacks
In many cases browsers will happily let a script from another website make cross-origin requests to your 
  API; it just prevents them from reading any response. Such an attack is known as Cross-Site Request 
  Forgery because the malicious site can create fake requests to your API that appear to come from a
  genuine client.
DEFINITION Cross-site request forgery (CSRF, pronounced “sea-surf”) occurs when an attacker makes a 
  cross-origin request to your API and the browser sends cookies along with the request. The request is 
  processed as if it was genuine unless extra checks are made to prevent these requests.

  SameSite cookies
   When a cookie is marked as SameSite, it will only be sent on requests that originate from the same
   registerable domain that originally set the cookie. This means that when the malicious site from Polly’s 
   link tries to send a request to the Natter API, the browser will send it without the session cookie 
   and the request will be rejected by the server
DEFINITION
   A SameSite cookie will only be sent on requests that originate from the same domain that originally set 
   the cookie. Only the registerable domain is examined, so api.payments.example.com and www .example.com
   are considered the same site, as they both have the registerable domain of example.com. On the other hand, 
   www.example.org (different suffix) and www.different.com are considered different sites. Unlike an origin, 
   the protocol and port are not considered when making same-site decisions.

The public suffix list
  SameSite cookies rely on the notion of a registerable domain, which consists of a top-level domain plus 
  one more level. For example, .com is a top-level domain, so example.com is a registerable domain, but 
  foo.example.com typically isn't. The situ- ation is made more complicated because there are some domain 
  suffixes such as .co.uk, which aren’t strictly speaking a top-level domain (which would be .uk) but should 
  be treated as if they are. There are also websites like github.io that allow any- body to sign up and 
  register a sub-domain, such as neilmadden.github.io, making github.io also effectively a top-level domain.
  Because there are no simple rules for deciding what is or isn’t a top-level domain, Mozilla maintains an 
  up-to-date list of effective top-level domains (eTLDs), known as the public suffix list (https://publicsuffix.org).
  A registerable domain in SameSite is an eTLD plus one extra level, or eTLD + 1 for short. You can submit 
  your own website to the public suffix list if you want your sub-domains to be treated as effectively 
  independent websites with no cookie sharing between them, but this is quite a drastic measure to take.

To mark a cookie as SameSite, you can add either SameSite=lax or SameSite=strict on the Set-Cookie header, 
  just like marking a cookie as Secure or HttpOnly (section 4.3.2). The difference between the two modes 
  is subtle. In strict mode, cookies will not be sent on any cross-site request, including when a user just 
  clicks on a link from one site to another. This can be a surprising behavior that might break traditional 
  websites. To get around this, lax mode allows cookies to be sent when a user directly clicks on a link but 
  will still block cookies on most other cross-site requests. Strict mode should be preferred if you can 
  design your UI to cope with missing cookies when following links.
  For example, many single-page apps work fine in strict mode because the first request
  when following a link just loads a small HTML template and the JavaScript imple-
  menting the SPA. Subsequent calls from the SPA to the API will be allowed to include
  cookies as they originate from the same site.

DEFINITION
  SHA-256 is a cryptographically secure hash function designed by the US National Security Agency that 
  produces a 256-bit (32-byte) output value. SHA-256 is one variant of the SHA-2 family of secure hash algorithms
  specified in the Secure Hash Standard (https://doi.org/10.6028/NIST.FIPS .180-4), which replaced the older 
  SHA-1 standard (which is no longer considered secure). SHA-2 specifies several other variants that produce 
  different output sizes, such as SHA-384 and SHA-512. There is also now a newer SHA-3 standard (selected 
  through an open international competition), with variants named SHA3-256, SHA3-384, and so on, but SHA-2 
  is still considered secure and is widely implemented.

Timing attacks
  A timing attack works by measuring tiny differences in the time it takes a computer to process different inputs
  to work out some information about a secret value that the attacker does not know. Timing attacks can measure 
  even very small differences in the time it takes to perform a computation, even when carried out over the 
  internet. The classic paper Remote Timing Attacks are Practical by David Brumley and Dan Boneh of Stanford 
  (2005; https://crypto.stanford.edu/~dabo/papers/ssl-timing.pdf) demonstrated that timing attacks are practical 
  for attacking computers on the same local network, and the techniques have been developed since then. Recent
  research shows you can remotely measure timing differences as low as 100 nanoseconds over the internet 
  (https://papers.mathyvanhoef.com/usenix2020.pdf). Consider what would happen if you used the normal String 
  equals method to compare the hash of the session ID with the anti-CSRF token received in a header. In most 
  programming languages, including Java, string equality is implemented with a loop that terminates as soon as 
  the first non-matching character is found. This means that the code takes very slightly longer to match if 
  the first two characters match than if only a single character matches. A sophisticated attacker can measure 
  even this tiny difference in timing. They can then simply keep sending guesses for the anti-CSRF token. First, 
  they try every possible value for the first character (64 possibilities because we are using base64-encoding) 
  and pick the value that took slightly longer to respond. Then they do the same for the second character, 
  and then the third, and so on. By finding the character that takes slightly longer to respond at each step, 
  they can slowly recover the entire anti-CSRF token using time only proportional to its length, rather than 
  needing to try every possible value. For a 10-character Base64-encoded string, this changes the number of 
  guesses needed from around 64 10 (over 1 quintillion possibilities) to just 640. Of course, this attack 
  needs many more requests to be able to accurately measure such small timing differences (typically many 
  thousands of requests per character), but the attacks are improving all the time. The solution to such 
  timing attacks is to ensure that all code that performs comparisons or lookups using secret values take a 
  constant amount of time regardless of the value of the user input that is supplied. To compare two strings 
  for equality, you can use a loop that does not terminate early when it finds a wrong value. The following 
  code uses bitwise XOR (^) and OR (|) operators to check if two strings are equal. The value of c will only 
  be zero at the end if every single character was identical. 
    if (a.length != b.length) return false;
      int c = 0;
    for (int i = 0; i < a.length; i++)
      c |= (a[i] ^ b[i]);
    return c == 0;
  This code is very similar to how MessageDigest.isEqual is implemented in Java. Check the documentation 
  for your programming language to see if it offers a similar facility.

